/*
 * schedule.c
 *
 *  Created on: Oct 27, 2025
 *      Author: ASUS
 */


#include "schedule.h"

Tasks taskList[SCH_MAX_TASKS];
uint8_t currentTasks = 0;
uint32_t ERROR_CODE_G = 0;

void SCH_Init(void) {
SCH_Delete_All_Tasks();
currentTasks = 0;


HAL_GPIO_WritePin(led_0_GPIO_Port, led_0_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(led_red_GPIO_Port, led_red_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(led_yellow_GPIO_Port, led_yellow_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(led_green_GPIO_Port, led_green_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);


}

uint32_t SCH_Add_Task(void (*task)(void), uint32_t delay, uint32_t period) {
if (currentTasks == SCH_MAX_TASKS) {
ERROR_CODE_G = ERROR_SCH_TOO_MANY_TASKS;
return ERROR_CODE_G;
}
taskList[currentTasks].funcPtr = task;
taskList[currentTasks].delay = delay;
taskList[currentTasks].period = period;
taskList[currentTasks].runme = 0;
taskList[currentTasks].taskID = currentTasks;
taskList[currentTasks].isEmpty = false;
taskList[currentTasks].isOneShot = (period == 0);
currentTasks++;
return currentTasks;
}

void SCH_Update(void) {
for (int i = 0; i < SCH_MAX_TASKS; i++) {
if (taskList[i].delay > 0 && taskList[i].isEmpty == false) {
taskList[i].delay--;
if (taskList[i].delay == 0) {
taskList[i].runme++;
taskList[i].delay = taskList[i].period;
}
}
}
}

void SCH_Dispatch_Tasks(void) {
for (int i = 0; i < SCH_MAX_TASKS; i++) {
if (taskList[i].runme > 0 && taskList[i].isEmpty == false) {
taskList[i].runme--;
(*taskList[i].funcPtr)();
if (taskList[i].isOneShot == true) {
SCH_Delete_Task(taskList[i].taskID);
}
}
}
}

uint32_t SCH_Delete_Task(uint32_t taskID) {
if (taskID >= SCH_MAX_TASKS) {
ERROR_CODE_G = ERROR_SCH_INVALID_INDEX;
return ERROR_CODE_G;
}
if (taskList[taskID].funcPtr == NULL) {
ERROR_CODE_G = ERROR_SCH_INVALID_INDEX;
return ERROR_CODE_G;
}
if (taskID == SCH_MAX_TASKS - 1) {
taskList[taskID].funcPtr = NULL;
taskList[taskID].delay = 0;
taskList[taskID].period = 0;
taskList[taskID].runme = 0;
taskList[taskID].taskID = 0;
taskList[taskID].isEmpty = true;
taskList[taskID].isOneShot = false;
currentTasks--;
} else {
for (int i = taskID; i < SCH_MAX_TASKS - 1; i++) {
taskList[i] = taskList[i + 1];
}
taskList[SCH_MAX_TASKS - 1].funcPtr = NULL;
taskList[SCH_MAX_TASKS - 1].delay = 0;
taskList[SCH_MAX_TASKS - 1].period = 0;
taskList[SCH_MAX_TASKS - 1].runme = 0;
taskList[SCH_MAX_TASKS - 1].taskID = 0;
taskList[SCH_MAX_TASKS - 1].isEmpty = true;
taskList[SCH_MAX_TASKS - 1].isOneShot = false;
currentTasks--;
}
return taskID;
}

void SCH_Delete_All_Tasks(void) {
for (int i = 0; i < SCH_MAX_TASKS; i++) {
SCH_Delete_Task(i);
}
}
